'''
### 문제 설명

Daedalus는 "욕심부리지 마"라는 게임을 하고 있다. 이 게임에서는 **N명의 플레이어**가 원형 테이블에 앉아, 각각 **1, 10, 100, 1000, 10000점**이 적힌 다섯 장의 카드를 가지고 있다.

게임이 시작되면 **플레이어들끼리는 대화를 나눌 수 없고**, 게임은 **M개의 라운드**로 진행된다.

각 라운드에서 **은행**이 하나의 **예산 B**를 제시한다. 그 후 모든 플레이어는 **자신의 카드 중 하나를 선택하여 뒷면으로 테이블에 내려놓는다**. 모든 플레이어가 선택을 마치면, 은행은 **모든 카드를 공개**한다.

* **모든 플레이어가 낸 카드의 총합이 예산 B 이하**라면, **모든 플레이어는 자신이 낸 카드만큼의 점수를 획득**한다.
* 하지만 **총합이 예산을 초과**하면, **모든 플레이어는 점수를 얻지 못한다.**

각 플레이어는 사용한 카드를 **다음 라운드 전에 돌려받는다**.

플레이어들은 모두 **매우 합리적**이며, 자신의 점수를 **최대화**하고 후회를 **최소화**하고자 한다. 이 상황에서, 당신이라면 협동하겠는가? 아니면 배신하겠는가?

다음의 예시를 보자. Daedalus는 총 **10점**을 획득했다. 성공한 라운드는 첫 번째 라운드뿐이었다. 하지만 나중에 다시 생각해보니, 첫 번째 라운드에서 **100점**, 세 번째 라운드에서 **10점**을 골랐다면, 총 **110점을 획득**할 수 있었음을 깨달았다. 즉, **100점의 추가 이득**을 얻을 수 있었던 것이다.
(단, 이는 **다른 플레이어들이 선택한 카드는 그대로 유지된다고 가정**했을 때에만 유효하다.)

| 라운드 | 예산 B | Daedalus | Iapyx | Icarus | Ariadne | Minos | 합계   | 결과 |
| --- | ---- | -------- | ----- | ------ | ------- | ----- | ---- | -- |
| 1   | 300  | 10       | 100   | 10     | 1       | 10    | 131  | 성공 |
| 2   | 1100 | 100      | 10    | 100    | 1       | 1000  | 1211 | 실패 |
| 3   | 1200 | 100      | 100   | 10     | 1       | 1000  | 1211 | 실패 |

이제, 각 라운드에서 **다른 플레이어들이 선택한 카드는 고정된 상태**에서, Daedalus가 **각 라운드마다 가장 점수가 많이 나올 수 있도록 최적으로 카드를 선택했을 때**
\=> **얼마나 많은 추가 점수를 얻을 수 있었는지**를 계산해야 한다.

---

### 입력

* 첫 번째 줄: 두 정수 N과 M (각각 플레이어 수, 라운드 수) (1 ≤ N ≤ 20, 1 ≤ M ≤ 50)
* 이후 M개의 줄: 각 라운드에 대한 정보

  * 정수 B (1 ≤ B ≤ 1,000,000): 해당 라운드의 예산
  * 정수 C₁, C₂, ..., Cₙ (각 Ci ∈ {1, 10, 100, 1000, 10000}): 해당 라운드에서 각 플레이어가 선택한 카드

    * **C₁은 항상 Daedalus가 선택한 카드이다.**

---

### 출력

* Daedalus가 **각 라운드에서 최적으로 카드를 선택했다면** 얻을 수 있었던 **총 추가 점수**를 한 줄에 출력하시오.

---

예제 입력 1
5 3
300 10 100 10 1 10
1100 100 10 100 1 1000
1200 100 100 10 1 1000


예제 출력 1 
100

예제 입력 2 
3 2
2000 1000 1000 1000
21 1 1 10

예제 출력 2 
9

'''

N, M = map(int, input().split())
cards = [1, 10, 100, 1000, 10000]
org_point = 0
ex_point = 0
for i in range(M):
    round = list(map(int, input().split()))
    B, D, ex = round[0], round[1], round[2:]
    bound = B-sum(ex) # 예산 - 나머지 = 여유분
    if bound <= 0: # 여유분이 없으면
        continue # 다이달로스는 어떤 카드를 내든 점수를 얻을 수 없다. 스킵
    if D <= bound: # 여유분보다 D가 작으면
        org_point += D # 다이달로스의 선택은 그 자체로 가능한 수
    max_card = 0 # 카드 숫자에서 여유분보다 작거나 같은 수 중 가장 큰 수 구하기
    for card in cards: # 1 10 100 1000 차례로 검사
        if card <= bound: # 여유분보다 작거나 같으면
            max_card = max(max_card, card) # 갱신
        else: # 여유분보다 커지면 루프 종료
            break
    ex_point += max_card
print(ex_point - org_point)
